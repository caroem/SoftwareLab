<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Softwarelabor Aufgaben - SS2013</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Softwarelabor Aufgaben - SS2013</h1>
  <p class="author">

  </p>
</div>
<div class="section slide level1" id="übersicht">
<h1>Übersicht</h1>
<ul>
<li><p>Bearbeiten Sie bitte folgende Aufgaben. Sie haben das Softwarelabor bestanden, wenn Sie alle Aufgaben erfolgreich bearbeitet haben.</p></li>
<li><p>Sämtliche Aufgaben müssen im Softwarelabor persönlich vorgestellt werden. Abnahme durch Prof. Dr. Pape oder Prof. Dr. Sulzmann.</p></li>
<li><p>Abgabefristen siehe ILIAS</p></li>
<li><p>Es folgt eine kurze Beschreibung. Weitere Informationen entnehmen Sie bitte dem Source Code der zu jeder Aufgabe bereitgestellt wird (siehe ilias).</p></li>
</ul>
</div>
<div class="section slide level1" id="aufgabe-1-bitmanipulationen-c">
<h1>Aufgabe 1: Bitmanipulationen (C)</h1>
<h2 id="vertauschen-von-bytes">Vertauschen von Bytes</h2>
<p>Schreiben Sie eine Funktion die das Low Byte (Bits 0-7) und das High Byte (Bits 8-15) vertauscht. Z.B. aus der Zahl 0x4020 wird die Zahl 0x2040.</p>
<p>Verwenden Sie folgenden Funktionsprototypen.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">short</span> <span class="dt">int</span> switchLowHighByte(<span class="dt">short</span> <span class="dt">int</span> i);</code></pre>
<h2 id="serialisierungdeserialisierung-von-datenstrukturen">Serialisierung/Deserialisierung von Datenstrukturen</h2>
<p>Gegenben sind zwei enum Datentypen.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">enum</span> {
  Stop = <span class="dv">0</span>,
  Start = <span class="dv">1</span>,
  Finish = <span class="dv">5</span>,
  Fail = <span class="dv">255</span>
} Status;


<span class="kw">typedef</span> <span class="kw">enum</span> {
  One = <span class="dv">1</span>,
  Fifteen = <span class="dv">15</span>,
  Last = <span class="dv">255</span>
} Numbers;</code></pre>
<p>Ihre Aufgabe ist es jeweils Werte der beiden enums in ein Datenpacket der Groesse 16Bit zu packen (serialisieren). Werte des enums Status sollen dabei in das Low Byte und Werte des enums Numbers sollen in das High Byte gepackt werden.</p>
<p>Schreiben Sie eine weitere Funktion, die Werte der enums Status und Number aus einem 16Bit Wert entpackt (deserialisiert). Wir nehmen an, dass die enum Werte mittels der serialize Funktion verpackt wurden.</p>
<p>Verwenden Sie folgende Funktionsprototypen.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> serialize(Status s, Numbers n, <span class="dt">short</span> <span class="dt">int</span>* data);

<span class="dt">void</span> deserialize(<span class="dt">short</span> <span class="dt">int</span> data, Status* s, Numbers* n);</code></pre>
<h2 id="hinweise">Hinweise</h2>
<p>Die Schreibweise</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">enum</span> {
  Stop = <span class="dv">0</span>,
  Start = <span class="dv">1</span>,
  Finish = <span class="dv">5</span>,
  Fail = <span class="dv">255</span>
} Status;</code></pre>
<p>vereint die Deklaration eines enum und die Einführung einer Abkürzung. Ausführlicher</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">enum</span> StatusEnum {
  Stop = <span class="dv">0</span>,
  Start = <span class="dv">1</span>,
  Finish = <span class="dv">5</span>,
  Fail = <span class="dv">255</span>
};
<span class="kw">typedef</span> <span class="kw">enum</span> StatusEnum Status;</code></pre>
<h2 id="tips-und-tricks">Tips und Tricks</h2>
<h3 id="bitoperationen">Bitoperationen</h3>
<p>Sollten immer auf <code>unsigned</code> ausgeführt werden. Lokaler Typcast!</p>
<h3 id="hexadezimal-darstellung">Hexadezimal Darstellung</h3>
<p>C unterstützt die Darstellung und Ausgabe von Zahlen in Hexadezimal Darstellung.</p>
<pre class="sourceCode c"><code class="sourceCode c">  <span class="dt">short</span> <span class="dt">int</span> zahl = <span class="bn">0x2040</span>;
  printf(<span class="st">&quot;%x </span><span class="ch">\n</span><span class="st">&quot;</span>, zahl);</code></pre>
<p>Dies ist eine Hilfe beim Testen obiger Funktionen.</p>
<h3 id="rückgabe-als-referenz">Rückgabe als Referenz</h3>
<p><code>serialize</code> und <code>deserialize</code> verwenden die Methode <em>Rückgabe als Referenz</em>.</p>
<h3 id="testen-auf-erwartetes-ergebnis">Testen auf erwartetes Ergebnis</h3>
<p>Ein <em>Testfall</em> besteht im allgemeinen aus</p>
<ol style="list-style-type: decimal">
<li>Setzen der Eingabe</li>
<li>Ausführung</li>
<li>Protokollierung der Ausgabe</li>
</ol>
<p>Der Testfall ist erfolgreich, falls die Ausgabe mit dem erwarteten Ergebnis übereinstimmt.</p>
<p>Im unseren Fall, ist es recht einfach, das erwartete Ergebnis zu Beschreibung, falls z.B. <code>switchLowHighByte</code> zweimal ausgeführt wird.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">enum</span> TestEnum {
  OK,
  FAIL
};
<span class="kw">typedef</span> <span class="kw">enum</span> TestEnum Test;

Test testLowHigh(<span class="dt">short</span> <span class="dt">int</span> i) {
  Test t;
  <span class="kw">if</span>(i == switchLowHighByte(switchLowHighByte(i))) 
    t = OK;
  <span class="kw">else</span>
    t = FAIL;

  <span class="kw">return</span> t;
}</code></pre>
<p>Als Aufgabe für Sie bleibt die Auswahl einer Reihen von signifikanten Testeingaben.</p>
<p><em>Beachte</em>: Obige Testeigenschaft <code>testLowHigh</code> ist notwendig aber nicht hinreichend für die Korrektheit von <code>switchLowHighByte</code>.</p>
<ul>
<li>Notwendig weil falls <code>switchLowHighByte</code> korrekt ist die Testeigenschaft sicherlich git.</li>
<li>Nicht hinreichend weil z.B. eine fehlerhafte Implementierung in der immer die Eingabe unverändert zurückgeliefert wird, die Testeigenschaft erfüllt, nicht aber die Anforderungen an <code>switchLowHighByte</code>.</li>
</ul>
<h3 id="test-set-up-serializedeserialize">Test Set-up serialize/deserialize</h3>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Test testSD(Status s, Numbers n) {
 Test t;
 <span class="dt">short</span> <span class="dt">int</span> data;
 Status s2;
 Numbers n2;
 
 <span class="co">// Test execution</span>
 serialize(s, n, &amp;data);
 deserialize(data, &amp;s2, &amp;n2);

 <span class="kw">if</span>(s2 == s &amp;&amp; n2 == n) {
    t = OK;
 }
 <span class="kw">else</span> {
    t = FAIL;
 }
 <span class="kw">return</span> t;
}</code></pre>
</div>
<div class="section slide level1" id="aufgabe-2-erkennen-von-mustern-c">
<h1>Aufgabe 2: Erkennen von Mustern (C)</h1>
<p>In dieser Aufgabe betrachten wir Strings und Manipulationen auf Strings. In C, ein String ist repräsentiert als eine Sequenz von alphanumerischen Zeichen.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> s1[<span class="dv">10</span>];
<span class="dt">char</span>* s2;
<span class="dt">char</span>* s3[<span class="dv">5</span>];
<span class="dt">char</span> s4[<span class="dv">5</span>][<span class="dv">6</span>];
<span class="dt">char</span>** s5;</code></pre>
<ul>
<li>s1 beschreibt einen String fester Größe.</li>
<li>s2 ist ein Zeiger (Pointer) auf das erste Element eines Strings. Der vom String belegte Speicherbereich wird im Regelfall dynamisch angelegt</li>
<li>s3 beschreibt ein Array von 5 Strings, wobei die einzelnen Strings durch Zeiger beschrieben sind.</li>
<li>s4 beschreibt ein Array von 5 Strings,wobie die einzelnen Strings von fester Größe sind.</li>
<li>s5 beschreibt einen Zeiger auf einen String</li>
</ul>
<p>WICHTIG: Das Ende des Strings wir gekennzeichnet durch das Nullterminator Zeichen:</p>
<pre class="sourceCode c"><code class="sourceCode c">&#39;\<span class="dv">0</span>&#39;</code></pre>
<h2 id="erkennen-des-längsten-suffix-nach-einem-vorgegebenen-muster">Erkennen des längsten Suffix nach einem vorgegebenen Muster</h2>
<p>Erste Teilaufgabe ist es eine Funktion zu schreiben, die den längsten suffix (Endung) liefert, in der keine zwei hintereinander folgenden Doppelpunkte (::) vorkommen. Als Eingabe betrachte man folgende Strings</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="st">&quot;Ha::ll::o&quot;</span>
<span class="st">&quot;47::11&quot;</span></code></pre>
<p>Längste Endungen für obige Beispiele sind</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="st">&quot;o&quot;</span>
<span class="st">&quot;11&quot;</span> </code></pre>
<p>Verwenden Sie folgenden Funktionsprototypen.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* extract(<span class="dt">char</span>* input);</code></pre>
<p>In obiger Funktion wird das Ergebnis als return Wert geliefert. Als Variante, verwenden Sie als Rückgabenwert einen Pointer auf einen Pointer. Wieso reicht ein Pointer nicht aus?</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> extract2(<span class="dt">char</span>* input, <span class="dt">char</span>** output)</code></pre>
<h3 id="freiwillige-zusatzaufgabe">Freiwillige Zusatzaufgabe:</h3>
<p>Verallgemeinern Sie Ihre Lösung: Das Muster zur Berechnung des längsten Suffix ist ein zusätzlicher Parameter.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* extract(<span class="dt">char</span>* pattern, <span class="dt">char</span>* input);</code></pre>
<h2 id="zählen-von-wörtern">Zählen von Wörtern</h2>
<p>Ein Wort ist eine Sequenz von Zeichen in der das Leerzeichen (white-space) nicht vorkommt. Aufgabe ist es eine Funktion zu schreiben, die die Anzahl der Wörter in einem String zählt.</p>
<p>Verwenden Sie folgenden Funktionsprototypen.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> count(<span class="dt">char</span>* input);</code></pre>
<p>Eine Lösung für diese Aufgaben wird im Softwarelabor besprochen. Verwenden Sie diese Lösung, um Ihre eigene Lösung zu testen. Details folgen im Labor.</p>
<h2 id="aufsammeln-von-wörtern">Aufsammeln von Wörtern</h2>
<p>Aufgabe ist es Wörter in einem String aufzusammeln.</p>
<p>Verwenden Sie folgenden Funktionsprototypen.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> breakIntoWords(<span class="dt">char</span> *line, <span class="dt">int</span> maxwords, <span class="dt">char</span> *words[])</code></pre>
<p>Die aufgesammelten Wörter sollen in dem Array von Strings words gespeichert werden. Die Größe von words ist fest vorgegeben durch maxwords. Sprich die maximale Anzahl der aufzusammelnden Wörter ist durch maxwords begrenzt. Die Anzahl der aufgesammelten Wörter wird als return Wert zurück geliefert.</p>
<p>Als Speicherplatz für die aufgesammelten Wörter soll der Eingabestring verwendet werden.</p>
<p>Überlegen Sie sich folgende Alternative, bei der der Speicherplatz für die aufgesammelten Wörter dynamisch angelegt wird. Was sind die Vor-/Nachteile?</p>
<h2 id="tips-und-tricks-1">Tips und Tricks</h2>
<h3 id="string-initialisierung">String Initialisierung</h3>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> s1[] = <span class="st">&quot;Hallo&quot;</span>;
<span class="dt">char</span> s2[] = { &#39;H&#39;, &#39;a&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39; };</code></pre>
<p>Die Initialisierung von <code>s2</code> enthält einen typischen Fehler. Was ist falsch?</p>
<p>Zur Erinnerung. Jeder String muss mit Null terminiert werden wobei wir die Null durch das Zeichen <code>'\0'</code> beschreiben. Diese Zeichen fehlt im Falle von `s2. Richtig muss es also lauten</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> s1[] = <span class="st">&quot;Hallo&quot;</span>;
<span class="dt">char</span> s2[] = { &#39;H&#39;, &#39;a&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, `\<span class="dv">0</span>` };</code></pre>
<p>Im Falle der Notation <code>&quot;Hallo&quot;</code> wird automatisch die Null angehängt.</p>
<h3 id="zählen-von-wörtern-1">Zählen von Wörtern</h3>
<p>Wir entwickeln eine Musterlösung für diese Teilaufgabe. Wichtig dabei ist der Nachweis der Korrektheit.</p>
<p>Um ein erstes Verständnis zu bekommen betrachten wir mögliche Eingaben und die erwarteten Ausgaben.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">count(<span class="st">&quot;&quot;</span>) ==&gt; <span class="dv">0</span>
count(<span class="st">&quot;Hallo&quot;</span>) ==&gt; <span class="dv">1</span>
count(<span class="st">&quot;  Hallo&quot;</span>) ==&gt; <span class="dv">1</span>
count(<span class="st">&quot;  Ha llo&quot;</span>) ==&gt; <span class="dv">2</span></code></pre>
<p>Bevor man mit der Implementierung anfängt ist es elementar wichtig genau die Aufgabenstellung zu analysieren. <em>WAS</em> genau ist gefordert? <em>WAS</em> sind typische Eingaben und die erwarteten Ergebnisse?</p>
<p>Das <em>WIE</em> implementiere ich die Aufgabenstellung ist hier erst einmal zweitrangig.</p>
<p>Deshalb entwerfen wir als erstes einen Testrahmen, mit dessen Hilfe wir unsere Implementierung testen können. Von der &quot;Java&quot; Vorlesung sind Sie mit Unit-Tests vertraut. Solch ein Unit-Test Framework steht uns hier nicht zur Verfügung (gibt es natürlich auch für C/C++). Den notwendigen Testrahmen haben wir uns aber schnell selber gebaut.</p>
<p>Zuerst beschreiben wir die möglichen Testergebnisse.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">enum</span> {
  OK,
  FAIL
} Test;</code></pre>
<p>Ein Testfall besteht aus einem String und dem erwarteten Ergebnis. Wir schreiben eine kleine Hilfsfunktion, die einen Testfall ausführt und auf das erwartete Ergebnis testet.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Test testCount(<span class="dt">char</span>* input, <span class="dt">int</span> expected) {
  Test t;
  
  <span class="kw">if</span>(expected == count(input)) {
    t = OK;
  }
  <span class="kw">else</span> {
    t = FAIL;
  }
  <span class="kw">return</span> t;
}</code></pre>
<p>Wir werden sicherlich eine Reihe von Testfällen benötigen, deshalb fassen wir einen Testfall in einer Struktur zusammen.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">char</span>* input;
  <span class="dt">int</span> expected;
} TestCase;</code></pre>
<p>Folgende Hilfsfunktion erlaubt uns die automatische Ausführung einer ganzen Reihe von Testfällen.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> runTests(<span class="dt">int</span> no, TestCase test[]) {
  Test t;
  <span class="dt">int</span> i;

  <span class="kw">for</span>(i=<span class="dv">0</span>; i &lt; no; i++) {
    printf(<span class="st">&quot;Test %d: &quot;</span>, i);
    t = testCount(test[i].input, test[i].expected);
    <span class="kw">if</span>(OK == t)
      printf(<span class="st">&quot;OK </span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">if</span>(FAIL == t)
      printf(<span class="st">&quot;FAIL </span><span class="ch">\n</span><span class="st">&quot;</span>);
  }
}</code></pre>
<p>Eingabe <code>no</code> beschreibt die Anzahl der Testfälle. Die eigentlichen Testfälle werden als Array <code>test</code> bestehend aus Strukturen des Typs <code>TestCase</code> übergeben. Auf jeden Testfall wenden wir die Hilfsfunktion <code>testCount</code> an.</p>
<p>In unseren Fall protokollieren wir die Testergebnisse durch Aufgabe auf der Konsole. In Industrieprojekten werden die Testergebnisse normalerweise auf Platte geschrieben und mit der Versionsnummer der getesteten Software versehen.</p>
<p>Hier ist eine Auswahl signifikanter Testfälle.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {
  <span class="dt">const</span> <span class="dt">int</span> testNo = <span class="dv">9</span>;
  TestCase tests[<span class="dv">9</span>] = { 
       {<span class="st">&quot;&quot;</span>, <span class="dv">0</span>},
       {<span class="st">&quot;Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;  Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;  Hallo  &quot;</span>, <span class="dv">1</span>},              

       {<span class="st">&quot;Hal lo&quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot; Hal lo&quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot;Hal lo &quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot; Hal lo  &quot;</span>, <span class="dv">2</span>}              
     };

  runTests(testNo,tests);
}</code></pre>
<p>Den Testrahmen haben wir also, wir haben aber immer noch keine einzige Zeile der Funktion <code>count</code> implementiert! Keine Angst kommt gleich. Die wichtige Nachricht an dieser Stelle ist: Ein Grossteil der Entwicklungszeit wird nicht auf das <em>WIE</em> verwendet, der meiste Entwicklungsaufwand beschäftigt sich mit <em>WAS</em>:</p>
<ul>
<li>... soll die Software eigentlich leisen?</li>
<li>... ging schief, wo liegt der Fehler?</li>
<li>...</li>
</ul>
<p>Nun endlich zur eigentlichen Implementierung. Betrachten wir noch einmal die Beispieleingaben und -ausgaben.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">count(<span class="st">&quot;&quot;</span>) ==&gt; <span class="dv">0</span>
count(<span class="st">&quot;Hallo&quot;</span>) ==&gt; <span class="dv">1</span>
count(<span class="st">&quot;  Hallo&quot;</span>) ==&gt; <span class="dv">1</span>
count(<span class="st">&quot;  Ha llo&quot;</span>) ==&gt; <span class="dv">2</span></code></pre>
<p>Im Falle des leeren Strings geben wir <code>0</code> zurück. Ansonsten suchen wir den Anfang eines Wortes? WIE machen wir das?</p>
<p>Entweder (a) wir befinden uns schon am Anfang eines Wortes, oder (b) das aktuelle Zeichen ist ein Leerzeichen.</p>
<p>Im Fall (b) überspringen wir alle Leerzeichen. Aha, wir haben die Aufgabe zerlegt in eine Teilaufgabe. Hier ist eine Funktion, die die Teilaufgabe (a) umsetzt.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span>* leerzeichen(<span class="dt">char</span>* input) {
  <span class="kw">while</span>(*input == &#39; &#39;) 
    input++;
  <span class="kw">return</span> input;
}</code></pre>
<p>Wir &quot;iterieren&quot; durch den String solange bis wir auf ein Zeichen treffen, welches nicht eine Leerzeichen ist. Rückgabe ist ein Zeiger auf das getroffene Nicht-Leerzeichen.</p>
<p>Betrachten wir Fall (a). Wir befinden uns am Anfang eines Wortes. Ein Wort besteht aus einer Sequenz von Nicht-Leerzeichen. Also iterieren wir durch den String bis wir auf ein Leerzeichen treffen. Das stimmt fast! Zu beachten ist hier der Spezialfall, dass wir das Ende des Strings erreichen. Fall (a) lässt sich wiederum sehr einfach mit Hilfe einer Funktion beschreiben.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span>* zeichen(<span class="dt">char</span>* input) {
  <span class="kw">while</span>(*input != &#39;\<span class="dv">0</span>&#39; &amp;&amp; *input != &#39; &#39;) 
    input++;
  <span class="kw">return</span> input;
}</code></pre>
<p>Wir haben jetzt die einzelnen Teilaufgaben. Damit lässt sich nun die <code>count</code> Aufgabe einfach lösen.</p>
<p>Zuerst in Pseudo-Code:</p>
<p>Solange das Ende nicht erreicht ist:</p>
<ol style="list-style-type: decimal">
<li>Überspringe alle Leerzeichen</li>
<li><p>Fall Zeichen gefunden</p>
<ol style="list-style-type: lower-alpha">
<li>zähle Anzahl gefunder Wörter hoch</li>
<li>Gehe zu Wortende</li>
</ol></li>
</ol>
<p>Hier ist die (literale) Umsetzung.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> count(<span class="dt">char</span>* input) {
  <span class="dt">int</span> cnt = <span class="dv">0</span>;

  <span class="kw">while</span>(*input != &#39;\<span class="dv">0</span>&#39;) {
    input = leerzeichen(input);    
    <span class="kw">if</span>(*input != &#39;\<span class="dv">0</span>&#39;) {
      cnt++;
      input = zeichen(input);
    }
  }
  <span class="kw">return</span> cnt;
}</code></pre>
<h4 id="als-anhang-der-komplette-programmcode">Als Anhang der komplette Programmcode</h4>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;stdio.h&quot;</span>

<span class="co">// Ueberspringe alle Leerzeichen</span>
<span class="co">// Rueckgabe ist Zeiger auf das erste Nichtleerzeichen</span>
<span class="dt">char</span>* leerzeichen(<span class="dt">char</span>* input) {
  <span class="kw">while</span>(*input == &#39; &#39;) 
    input++;
  <span class="kw">return</span> input;
}

<span class="co">// Scanne durch string solange bis wir auf ein</span>
<span class="co">// Leerzeichen oder das Ende des Strings treffen.</span>
<span class="co">// Effektiv ueberspringen wir ein Wort.</span>
<span class="co">// Rueckgabe: Zeiger auf Ende oder Leerzeichen.</span>
<span class="dt">char</span>* zeichen(<span class="dt">char</span>* input) {
  <span class="kw">while</span>(*input != &#39;\<span class="dv">0</span>&#39; &amp;&amp; *input != &#39; &#39;) 
    input++;
  <span class="kw">return</span> input;
}


<span class="dt">int</span> count(<span class="dt">char</span>* input) {
  <span class="dt">int</span> cnt = <span class="dv">0</span>;

  <span class="co">// Solange das Ende nicht erreicht ist:</span>
  <span class="co">// 1. Ueberspringe alle Leerzeichen</span>
  <span class="co">// 2. Falls Zeichen gefunden</span>
  <span class="co">//     (a) setze Zaehler hoch</span>
  <span class="co">//     (b) Gehe zu Wortende</span>

  <span class="kw">while</span>(*input != &#39;\<span class="dv">0</span>&#39;) {
    input = leerzeichen(input);    
    <span class="kw">if</span>(*input != &#39;\<span class="dv">0</span>&#39;) {
      cnt++;
      input = zeichen(input);
    }
  }
  <span class="kw">return</span> cnt;
}


<span class="kw">typedef</span> <span class="kw">enum</span> {
  OK,
  FAIL
} Test;

Test testCount(<span class="dt">char</span>* input, <span class="dt">int</span> expected) {
  Test t;
  
  <span class="kw">if</span>(expected == count(input)) {
    t = OK;
  }
  <span class="kw">else</span> {
    t = FAIL;
  }
  <span class="kw">return</span> t;
}


<span class="kw">typedef</span> <span class="kw">struct</span> {
  <span class="dt">char</span>* input;
  <span class="dt">int</span> expected;
} TestCase;


<span class="dt">void</span> runTests(<span class="dt">int</span> no, TestCase test[]) {
  Test t;
  <span class="dt">int</span> i;

  <span class="kw">for</span>(i=<span class="dv">0</span>; i &lt; no; i++) {
    printf(<span class="st">&quot;Test %d: &quot;</span>, i);
    t = testCount(test[i].input, test[i].expected);
    <span class="kw">if</span>(OK == t)
      printf(<span class="st">&quot;OK </span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">if</span>(FAIL == t)
      printf(<span class="st">&quot;FAIL </span><span class="ch">\n</span><span class="st">&quot;</span>);
  }
}


<span class="dt">int</span> main() {
  <span class="dt">const</span> <span class="dt">int</span> testNo = <span class="dv">9</span>;
  TestCase tests[<span class="dv">9</span>] = { 
       {<span class="st">&quot;&quot;</span>, <span class="dv">0</span>},
       {<span class="st">&quot;Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;  Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;  Hallo  &quot;</span>, <span class="dv">1</span>},              

       {<span class="st">&quot;Hal lo&quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot; Hal lo&quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot;Hal lo &quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot; Hal lo  &quot;</span>, <span class="dv">2</span>}              
     };

  runTests(testNo,tests);

}</code></pre>
</div>
<div class="section slide level1" id="aufgabe-3-string-klasse-mit-überladenen-operatoren-c">
<h1>Aufgabe 3: String Klasse mit überladenen Operatoren (C++)</h1>
<p>Erstellen Sie eine String-Klasse ohne zu Hilfenahme von STL, die es Ihnen erlaubt, den folgenden Code zu schreiben:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main() {
  String s1;
  String s2(<span class="st">&quot;Hello&quot;</span>);
  String s3(s2);
  s1 += s2; s2 = s3;
  cout &lt;&lt; s2 &lt;&lt; endl;
  cout &lt;&lt; s2[ <span class="dv">2</span> ] &lt;&lt; endl;
};</code></pre>
<p>Beachte</p>
<ul>
<li><p>Intern soll der String als ein Zeiger auf ein Zeichen dargestellt werden (wie in C).</p></li>
<li><p>Beim Kopieren und bei der Zuweisung soll der String dupliziert werden. Sie benötigen daher einen Kopierkonstruktor, Zuweisungsoperator und einen Destruktor</p></li>
<li><p>Folgende Operaten sollen überladen werden: += (Konkatenation), = (Zuweisung) und [] (Arrayzugriff)</p></li>
</ul>
</div>
<div class="section slide level1" id="aufgabe-4-reguläre-ausdrücke-und-automaten-c">
<h1>Aufgabe 4: Reguläre Ausdrücke und Automaten (C++)</h1>
<p>Diese Aufgabe besteht aus folgenden Teilen:</p>
<ol style="list-style-type: decimal">
<li><p>Vereinfachung regulärer Ausdrücke</p></li>
<li><p>Transformation Regulärer Ausdrücke in endliche Automaten</p></li>
<li><p>Ausführung des endlichen Automaten</p></li>
</ol>
<p>Teile der Aufgabe sind schon vorgegeben. Siehe Files <code>RE.h</code> und <code>FSA.h</code>. Ihre Aufgabe ist es, die fehlenden Teile zu vervollständigen.</p>
<h2 id="reguläre-ausdrücke">Reguläre Ausdrücke</h2>
<p>In der theoretischen Informatik haben sie schon reguläre Ausdrücke kennengelernt. Mittels regulärer Ausdrücke lassen sich reguläre Sprache beschreiben, wobei eine Sprache aus einer Menge von Wörtern besteht. Jedes Wort besteht aus einer endlichen Anzahl von Zeichen. In unserem Fall stellen wir Zeichen als <code>char</code> dar. Deshalb sind Wörter nichts anderes als Strings.</p>
<p>Wir betrachten folgende syntaktischen Konstrukte:</p>
<ul>
<li><code>eps</code> -- &quot;Epsilon&quot; der leere String</li>
<li><code>phi</code> -- &quot;Phi&quot; die leere Sprache</li>
<li><code>c</code> -- das Zeichen <code>c</code></li>
<li><code>r1 + r2</code> -- Alternative zwischen <code>r1</code> und <code>r2</code>
<ul>
<li>Auch geschrieben als <code>r1 | r2</code></li>
</ul></li>
<li><code>r1 r2</code> -- Verkettung/Konkatenation von <code>r1</code> mit <code>r2</code></li>
<li><code>r*</code> -- Kleenesche Hülle, entweder leerer String oder beliebige Verkettung von <code>r</code></li>
</ul>
<p>Die Sprache <code>L(r)</code> beschrieben durch den regulären Ausdruck <code>r</code> ist definiert wie folgt:</p>
<ul>
<li><code>L(phi) = {}</code></li>
<li><code>L(eps) = { eps }</code></li>
<li><code>L(c) = { c }</code></li>
<li><code>L(r1 + r2) = { w | w in L(r1) oder w in L(r2) }</code></li>
<li><code>L(r1 r2) = { w1 w2 | w1 in L(r1) und w2 in L(r2) }</code></li>
<li><code>L(r*) = { w | w = eps oder w=w1 ... wn jedes wi in  L(r)  }</code></li>
</ul>
<p>Im ersten Schritt bilden wir die Syntax von regulären Ausdrücken nach C++ ab. Dazu verwenden wir Vererbung.</p>
<pre class="sourceCode c"><code class="sourceCode c">class RE {};
class Phi : public RE {};
class Eps : public RE {};
class Ch : public RE {
 private:
  <span class="dt">char</span> c;
 public:
  Ch (<span class="dt">char</span> _c) { c = _c; }
};
class Alt : public RE {
 private:
  RE* r1;
  RE* r2;
 public:
  Alt (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
};
class Conc : public RE {
 private:
  RE* r1;
  RE* r2;
 public:
  Conc (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
};
class Star : public RE {
 private:
  RE* r;
 public:
  Star (RE* _r) { r = _r; }
};</code></pre>
<p>Z.B. die abgeleitete Klasse <code>Alt</code> repräsentiert die Alternativen zwischen zwei regulären Ausdrücken. Die Alternativen werden als private Instanzvariablen <code>r1</code> und <code>r2</code> gespeichert. Beides sind Zeiger weil, wie wir noch sehen werden, wir virtuelle Methoden auf der Basisklassen und den Ableitungen definieren werden. Der <code>Alt</code> Konstruktor bekommt als Argument zwei reguläre Ausdrücke in C++ Repräsentation und initialisiert die Instanzvariablen.</p>
<h2 id="standard-methoden-auf-regulären-ausdrücken">Standard Methoden auf Regulären Ausdrücken</h2>
<pre class="sourceCode c"><code class="sourceCode c">class RE {
 public:
  virtual REType ofType()=<span class="dv">0</span>;
  virtual string pretty()=<span class="dv">0</span>;
  virtual bool containsEps()=<span class="dv">0</span>;
};</code></pre>
<p><code>ofType</code> liefert einen enum Wert, der die Art des regulären Ausdrucks kennzeichnet. <code>pretty</code> ist eine &quot;pretty print&quot; Methode, die den regulären Ausdruck in einen String übersetzt. <code>containsEps</code> liefert <code>true</code> falls in der Sprache, die vom dem reguläre Ausdruck beschrieben wird, sich der leere String befindet.</p>
<p>Obige virtuelle Methoden sind schon für die abgeleiteten Klassen definiert. Zur Lösung der Aufgaben dürfen Sie weitere (virtuelle) Methoden zur Klasse <code>RE</code> hinzufügen.</p>
<p>Als Beispiel der Definition der virtuellen Methoden, betrachten wir die abgeleitete Klasse <code>Alt</code>.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">enum</span> REType {
  PhiType, EpsType, ChType,
  AltType, ConcType, StarType };

class Alt : public RE {
 private:
  RE* r1;
  RE* r2;
 public:
  Alt (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
  REType ofType() { <span class="kw">return</span> AltType; }
  string pretty() {
    string s(<span class="st">&quot;(&quot;</span>);
    s.append(r1-&gt;pretty());
    s.append(<span class="st">&quot;+&quot;</span>);
    s.append(r2-&gt;pretty());
    s.append(<span class="st">&quot;)&quot;</span>);
    <span class="kw">return</span> s;
  }
  bool containsEps() { 
    <span class="kw">return</span> (r1-&gt;containsEps() || r2-&gt;containsEps());
  }
};</code></pre>
<p>Die Syntax von regulären Ausdrücken ist fest vorgegeben. Sprich für die Klasse <code>RE</code> gibt es keine weiteren Ableitungen, ausser den oben beschriebenen. Deshalb benutzen wir einen enum, wobei die Tags des enums jede Ableitung der Klasse <code>RE</code> beschreiben. Z.B. <code>AltType</code> beschreibt <code>Alt</code>, <code>ConcType</code> beschreibt <code>Conc</code> usw. Deshalb liefert <code>ofType</code> für die Ableitung <code>Alt</code> den Wert <code>AltType</code>.</p>
<p>Im Falle von <code>pretty</code> wird ersichtlich, wieso wir virtuelle Methoden verwenden. <code>pretty</code> wird für jede Alternative aufgerufen. Zur Laufzeit wir dann basierend auf der konkreten Instanz der Alternativen, die geeignete <code>pretty</code> Definition ausgewählt.</p>
<p>Die resultierenden Strings werden dann mit &quot;+&quot; verbunden. Beachte: Mittels Klammern &quot;(&quot; und &quot;)&quot; wird eine eindeutige Darstellunge garantiert. Z.B.</p>
<pre class="sourceCode c"><code class="sourceCode c">  RE* r = new Conc (new Ch(&#39;c&#39;), new Alt(new Ch(&#39;a&#39;), new Ch(&#39;b&#39;)));
  cout &lt;&lt; r-&gt;pretty() &lt;&lt; endl;</code></pre>
<p>liefert <code>(c(a+b))</code>. Ohne die Klammern erhalten wir <code>ca+b</code> was nicht eindeutig ist. Natürlich könnten wir eine Präferenz zwischen den Alternativ-, Verkettungs- und Staroperator definieren, um die Anzahl der Klammern zu reduzieren (freiwillige Aufgabe).</p>
<p>Im Falle einer Alternative, ist der leere String enthalten, falls eine der beiden Alternativen den leeren String enthält. Die Methode <code>containsEps</code> setzt diese Vorgabe literal um.</p>
<h2 id="teilaufgabe-1-vereinfachung-regulärer-ausdrücke">Teilaufgabe 1: Vereinfachung Regulärer Ausdrücke</h2>
<p>Betrachte folgenden regulären Ausdruck.</p>
<pre><code>   eps ((a*)* (phi + b))</code></pre>
<p>Obiger Ausdruck kann vereinfacht werden in die Form</p>
<pre><code>   (a*) b</code></pre>
<p>Beide Ausdrücke sind äquivalent. Der letztere Ausdruck ist aber in einfacher und verständlicherer Form.</p>
<p>Ziel ist einen regulärern Ausdruck soweit wie möglich zu vereinfachen. Dazu verwenden wir Vereinfachungsregeln formuliert in der Form</p>
<pre><code> linkeSeite ==&gt; rechteSeite</code></pre>
<ol style="list-style-type: decimal">
<li><p><code>eps r ==&gt; r</code></p></li>
<li><p><code>r1 r2 ==&gt; phi</code> falls <code>phi in L(r1)</code> oder <code>phi in L(r2)</code></p></li>
<li><p><code>r* ==&gt; phi</code> falls <code>phi in L(r)</code></p></li>
<li><p><code>(r*)* ==&gt; r*</code></p></li>
<li><p><code>r + r ==&gt; r</code></p></li>
<li><p><code>r1 + r2 ==&gt; r2</code> falls <code>phi in L(r1)</code></p></li>
<li><p><code>r1 + r2 ==&gt; r1</code> falls <code>phi in L(r2)</code></p></li>
</ol>
<p>Für jede der obigen Regeln gilt <code>L(linkeSeite) = L(rechteSeite)</code>.</p>
<p>Angewandt auf unser Beispiel.</p>
<pre><code>      eps ((a*)* (phi + b))
==&gt;1  (a*)* (phi + b)
==&gt;4  a* (phi + b)
==&gt;6  a* b</code></pre>
<h3 id="weiteres-vorgehen">Weiteres Vorgehen</h3>
<p>Wir erweitern Klasse <code>RE</code> wie folgt.</p>
<pre class="sourceCode c"><code class="sourceCode c">class RE {
 public:
  ...  
  virtual bool isPhi()=<span class="dv">0</span>;
  virtual RE* simp() { <span class="kw">return</span> this; }
};</code></pre>
<p>Methode <code>isPhi</code> liefert <code>true</code> falls der Ausdruck die leere Sprache beschreibt und ist schon vordefiniert.</p>
<p>Methode <code>simp</code> führt die Vereinfachungsregeln aus. Per Default liefert <code>simp</code> den ürsprünglichen Ausdruck. Ihre Aufgabe ist es <code>simp</code> in den abgeleiteten Klassen geeignet zu erweitern.</p>
<p>Als Beispiel betrachte man <code>Alt</code> und die Umsetzung der Regeln 6 und 7.</p>
<pre class="sourceCode c"><code class="sourceCode c">RE* Alt::simp() { 
    <span class="kw">if</span>(r1-&gt;isPhi()) <span class="kw">return</span> r2;
    <span class="kw">if</span>(r2-&gt;isPhi()) <span class="kw">return</span> r1;

    <span class="kw">return</span> this;
}</code></pre>
<p>Implementieren Sie so viele wie mögliche obiger Vereinfachungsregeln. Für Regel 5 <code>r + r ==&gt; r</code> benötigen Sie eine Methode zum Test auf Gleichheit zwischen regulären Ausdrücken.</p>
<p>Beachte. In obiger Beispielimplementierung liefern wir als Rückgabewerte eine <em>flache</em> Kopie zurück. Wir müssen deshalb vorsichtig bei der Freigabe von Speicher sein, um nicht den gleichen Speicherbereich mehrfach freizugeben, was zu einer Laufzeitaufnaheme führt. Alternativ können Sie eine <em>tiefe</em> Kopie zurückliefern.</p>
<h2 id="transformation-regulärer-ausdrücke-in-automaten">Transformation Regulärer Ausdrücke in Automaten</h2>
<p>Die nächste Aufgabe ist die Transformation von regulären Ausdrücken in Automaten.</p>
<h3 id="algorithmische-beschreibung">Algorithmische Beschreibung</h3>
<p>Ein möglicher Algorithmus ist der Thompson NFA Algorithmus beschrieben hier:</p>
<p><a href="http://en.wikipedia.org/wiki/Thompson&#39;s_construction_algorithm">http://en.wikipedia.org/wiki/Thompson's_construction_algorithm</a></p>
<p>Gegeben einen regulären Ausdruck, zeigt der Algorithmus von Ken Thompson wie man einen nichtdeterministischen Automaten konstruiert.</p>
<p>Sie können natürlich sonst einen Algorithmus verwenden. Wichtig ist, dass der konstruierte Automat die gleiche Sprache akzeptiert, wie der reguläre Ausdruck.</p>
<h3 id="c-umsetzung">C++ Umsetzung</h3>
<p>Folgende Klassen sind gegeben. Bauen Sie Ihr Lösung auf Grundlage dieser Klassen auf.</p>
<pre class="sourceCode c"><code class="sourceCode c">class Transition;
class NFA;
class FSA;</code></pre>
<p><code>Transition</code> beschreibt eine Transition innerhalb eines Automaten. <code>NFA</code> beschreibt eine nicht-deterministischen Automaten, der aus einer Menge von Transitionen, einem Startzustand und einer Menge von Finalzuständen besteht. <code>FSA</code> ermöglicht die Ausführung eines NFA und wird erst später relevant.</p>
<p>Zuerst betrachen wir die Klasse <code>Transition</code>.</p>
<pre class="sourceCode c"><code class="sourceCode c">class Transition {
 private:
  <span class="dt">int</span> from; 
  <span class="dt">char</span> c; 
  <span class="dt">int</span> to;
  bool epsilon;
 public:

  Transition(<span class="dt">int</span> _from, <span class="dt">int</span> _to) {
    from = _from; to = _to; 
    epsilon = true;
  } 
  Transition(<span class="dt">int</span> _from, <span class="dt">char</span> _c, <span class="dt">int</span> _to) {
    from = _from; c = _c; to = _to; 
    epsilon = false;
  } 
  bool isEpsilonTransition() { <span class="kw">return</span> epsilon; }
  <span class="dt">int</span> toState() { <span class="kw">return</span> to; }
  bool trigger(<span class="dt">int</span> from, <span class="dt">char</span> c) {
    <span class="kw">return</span> (!epsilon &amp;&amp; from == this-&gt;from &amp;&amp; c == this-&gt;c);
  }
  bool trigger(<span class="dt">int</span> from) {
    <span class="kw">return</span> (epsilon &amp;&amp; from == this-&gt;from);
  }
};</code></pre>
<p>Zustände werden als Integer Werte repräsentiert. Eine Transition kann zwei Formen haben.</p>
<pre><code> from --- c ---&gt; to

 from ---------&gt; to</code></pre>
<p>Der Übergang von <code>from</code> nach <code>to</code> findet statt, falls die aktuelle Eingabe mit dem Zeichen <code>c</code> übereinstimmt, oder wir können spontan von <code>from</code> nach <code>to</code> übergehen. Letzer Fall ist eine sogeannte &quot;epsilon&quot; Transition. Die überladenen Konstruktoren von <code>Transition</code> erlauben die Konstruktion von Transitionen beider Arten.</p>
<p>Methode <code>isEpsilonTransition</code> unterscheidet zwischen beiden Arten. Überladene Methode <code>trigger</code> testet ob ein Übergang möglich ist. Methode <code>toState</code> liefert den Folgezustand.</p>
<p>Nun zu der <code>NFA</code> Klasse.</p>
<pre class="sourceCode c"><code class="sourceCode c">class NFA {
 private:
  vector&lt;Transition&gt; ts;
  <span class="dt">int</span> init;
  vector&lt;<span class="dt">int</span>&gt; final;

 public:
  NFA(vector&lt;Transition&gt; _ts, <span class="dt">int</span> _init, vector&lt;<span class="dt">int</span>&gt; _final) {
    ts = _ts;
    init = _init;
    final = _final;
  }

  friend class FSA;
};</code></pre>
<p>Ein <code>NFA</code> besteht aus einer Menge von Transitionen, einem Startzustand und einer Menge von Finalzuständen. Wir benutzen STL <code>vector</code> zur Speicherung von Transitionen und Finalzuständen.</p>
<p>Ihre Aufgabe ist die Implementierung folgender Funktion.</p>
<pre class="sourceCode c"><code class="sourceCode c">NFA transform(RE* r);</code></pre>
<h2 id="ausführung-nfa">Ausführung NFA</h2>
<p>Eine weitere Aufgabe ist die Ausführung des aus dem regulären Ausdrucks konstrukierten NFA. Der Rahmen zur Ausführung wird durch die Klasse <code>FSA</code> definiert.</p>
<pre class="sourceCode c"><code class="sourceCode c">class FSA : public NFA {
 private:
  vector&lt;<span class="dt">int</span>&gt; current;
  <span class="dt">void</span> closure();
 public:
  FSA(NFA fsa) : NFA(fsa.ts,fsa.init,fsa.final) {
    current.push_back(init);
    closure();
  }
  <span class="dt">void</span> reset();
  <span class="dt">void</span> step(<span class="dt">char</span> c);
  bool isFinal();

};</code></pre>
<p>Ein FSA nimmt einen NFA. Instanzvariable <code>current</code> beschreibt die Menge der &quot;aktiven&quot; Zustände. Beachte wir gehen von einem nicht-deterministischen Automaten aus. Im Falle eines deterministischen Automaten, würde die Menge aus genau einem Zustand bestehen.</p>
<p>Am Anfang wird <code>current</code> gleich dem Startzustand des NFA gesetzt. Übergänge finden nur statt (sprich Transitionen werden getriggert) bei Lesen eines Zeichens. Da der NFA &quot;epsilon&quot; Transitionen enthält, müssen wir die transitive Hülle der &quot;epsilon&quot; Transitionen bilden. Dies geschieht durch Aufruf der Methode <code>closure</code>.</p>
<p>Ihre Aufgabe ist es Methode <code>closure</code> zu implementieren. Für jeden Zustand <code>s1</code> in <code>current</code> und jede &quot;epsilon&quot; Transition <code>s2 -----&gt; s3</code>, fügen wir <code>s3</code> zu <code>current</code> hinzu falls folgende Bedingungen gelten:</p>
<ul>
<li>`s1 == s2'</li>
<li><code>s3</code> ist nicht schon enthalten in <code>current</code></li>
</ul>
<p>Dieser Vorgang wird solange ausgeführt, bis keine Zustände mehr zu <code>current</code> hinzugefügt werden können.</p>
<p>Methoden <code>reset</code>, <code>isFinal</code> und <code>step</code> sind schon gegeben.</p>
<p>Ein <code>reset</code> bedeutet, wir brechen die Ausführung ab, und starten neu:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> FSA::reset() {
    current.clear();
    current.push_back(init);
    closure();
}</code></pre>
<p>Methoden <code>isFinal</code> überprüft, ob wir einen Finalzustand erreicht haben:</p>
<pre class="sourceCode c"><code class="sourceCode c">bool FSA::isFinal() {
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; final.size(); i++) {
      <span class="kw">if</span>(find(current.begin(),current.end(),final[i]) != current.end())
    <span class="kw">return</span> true;
    }     
    <span class="kw">return</span> false;</code></pre>
<p>Methode <code>step</code> nimmt als Eingabe das aktuelle Zeichen <code>c</code>. Basierend auf der Menge der &quot;aktiven&quot; Zustände in <code>current</code>, werden alle Folgezustände berechnet die mit der Eingabe <code>c</code> erreicht werden können. Diese Menge wird gleich <code>current</code> gesetzt. Es folgt das bilden der transitiven Hülle der &quot;epsilon&quot; Transitionen mittels <code>closure</code>.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> FSA::step(<span class="dt">char</span> c) {
    vector&lt;<span class="dt">int</span>&gt; next;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; ts.size(); i++) {
      <span class="kw">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j &lt; current.size(); j++) {
        <span class="kw">if</span>(ts[i].trigger(current[j],c))
      next.push_back(ts[i].toState());
      }
    }
    current = next;
    closure();
}</code></pre>
</div>
<div class="section slide level1" id="anhang-zu-aufgabe-4">
<h1>Anhang zu Aufgabe 4</h1>
<h2 id="fsa.h"><code>FSA.h</code></h2>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// File: FSA.h</span>
<span class="co">// Endliche Automaten</span>

<span class="ot">#ifndef __FSA__</span>
<span class="ot">#define __FSA__</span>

<span class="ot">#include &lt;vector&gt;</span>

using namespace std;

class Transition;
class NFA;
class FSA;



class Transition {
 private:
  <span class="dt">int</span> from; 
  <span class="dt">char</span> c; 
  <span class="dt">int</span> to;
  bool epsilon;
 public:

  Transition(<span class="dt">int</span> _from, <span class="dt">int</span> _to) {
    from = _from; to = _to; 
    epsilon = true;
  } 
  Transition(<span class="dt">int</span> _from, <span class="dt">char</span> _c, <span class="dt">int</span> _to) {
    from = _from; c = _c; to = _to; 
    epsilon = false;
  } 
  bool isEpsilonTransition() { <span class="kw">return</span> epsilon; }
  <span class="dt">int</span> toState() { <span class="kw">return</span> to; }
  bool trigger(<span class="dt">int</span> from, <span class="dt">char</span> c) {
    <span class="kw">return</span> (!epsilon &amp;&amp; from == this-&gt;from &amp;&amp; c == this-&gt;c);
  }
  bool trigger(<span class="dt">int</span> from) {
    <span class="kw">return</span> (epsilon &amp;&amp; from == this-&gt;from);
  }
};

class NFA {
 private:
  vector&lt;Transition&gt; ts;
  <span class="dt">int</span> init;
  vector&lt;<span class="dt">int</span>&gt; final;

 public:
  NFA(vector&lt;Transition&gt; _ts, <span class="dt">int</span> _init, vector&lt;<span class="dt">int</span>&gt; _final) {
    ts = _ts;
    init = _init;
    final = _final;
  }

  friend class FSA;
};

class FSA : public NFA {
 private:
  vector&lt;<span class="dt">int</span>&gt; current;
  <span class="dt">void</span> closure();
 public:
  FSA(NFA fsa) : NFA(fsa.ts,fsa.init,fsa.final) {
    current.push_back(init);
    closure();
  }
  <span class="dt">void</span> reset();
  <span class="dt">void</span> step(<span class="dt">char</span> c);
  bool isFinal();

};

<span class="dt">void</span> FSA::reset() {
    current.clear();
    current.push_back(init);
    closure();
}

bool FSA::isFinal() {
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; final.size(); i++) {
      <span class="kw">if</span>(find(current.begin(),current.end(),final[i]) != current.end())
    <span class="kw">return</span> true;
    }     
    <span class="kw">return</span> false;
}

<span class="dt">void</span> FSA::closure() {
 <span class="co">// Ihre Aufgabe</span>
}

<span class="dt">void</span> FSA::step(<span class="dt">char</span> c) {
    vector&lt;<span class="dt">int</span>&gt; next;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; ts.size(); i++) {
      <span class="kw">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j &lt; current.size(); j++) {
        <span class="kw">if</span>(ts[i].trigger(current[j],c))
      next.push_back(ts[i].toState());
      }
    }
    current = next;
    closure();
}



<span class="ot">#endif // __FSA__</span></code></pre>
<h2 id="re.h"><code>RE.h</code></h2>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// File: RE.h</span>
<span class="co">// Reguläre Ausdrücke</span>

<span class="ot">#ifndef __RE__</span>
<span class="ot">#define __RE__</span>

<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>

using namespace std;


<span class="kw">enum</span> REType {
  PhiType,
  EpsType,
  ChType,
  AltType,
  ConcType,
  StarType };


<span class="co">// Basisklasse</span>
class RE {
 public:
  virtual REType ofType()=<span class="dv">0</span>;
  virtual string pretty()=<span class="dv">0</span>;
  virtual bool containsEps()=<span class="dv">0</span>;
  virtual bool isPhi()=<span class="dv">0</span>;
  virtual RE* simp() { <span class="kw">return</span> this; }
};

<span class="co">// Abgeleitete Klassen</span>

class Phi : public RE {
 public:
  REType ofType() { <span class="kw">return</span> PhiType; }
  string pretty() { <span class="kw">return</span> <span class="st">&quot;phi&quot;</span>; }
  bool containsEps() { <span class="kw">return</span> false; }
  bool isPhi() { <span class="kw">return</span> true; }
};

class Eps : public RE {
 public:
  REType ofType() { <span class="kw">return</span> EpsType; }
  string pretty() { <span class="kw">return</span> <span class="st">&quot;eps&quot;</span>; }
  bool containsEps() { <span class="kw">return</span> true; }
  bool isPhi() { <span class="kw">return</span> false; }
};

class Ch : public RE {
 private:
  <span class="dt">char</span> c;
 public:
  Ch (<span class="dt">char</span> _c) { c = _c; }
  REType ofType() { <span class="kw">return</span> ChType; }
  string pretty() {
    stringstream ss;
    ss &lt;&lt; c;
    <span class="kw">return</span> ss.str();
  }
  bool containsEps() { <span class="kw">return</span> false; }
  bool isPhi() { <span class="kw">return</span> false; }
};

class Alt : public RE {
 private:
  RE* r1;
  RE* r2;
 public:
  Alt (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
  REType ofType() { <span class="kw">return</span> AltType; }
  string pretty() {
    string s(<span class="st">&quot;(&quot;</span>);
    s.append(r1-&gt;pretty());
    s.append(<span class="st">&quot;+&quot;</span>);
    s.append(r2-&gt;pretty());
    s.append(<span class="st">&quot;)&quot;</span>);
    <span class="kw">return</span> s;
  }
  bool containsEps() { 
    <span class="kw">return</span> (r1-&gt;containsEps() || r2-&gt;containsEps());
  }
  bool isPhi() { 
    <span class="kw">return</span> (r1-&gt;isPhi() &amp;&amp; r2-&gt;isPhi());
  }
  RE* simp() { 
    <span class="kw">if</span>(r1-&gt;isPhi()) <span class="kw">return</span> r2;
    <span class="kw">if</span>(r2-&gt;isPhi()) <span class="kw">return</span> r1;

    <span class="kw">return</span> this;
  }
};

class Conc : public RE {
 private:
  RE* r1;
  RE* r2;
 public:
  Conc (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
  REType ofType() { <span class="kw">return</span> ConcType; }
  string pretty() {
    string s(<span class="st">&quot;(&quot;</span>);
    s.append(r1-&gt;pretty());
    s.append(r2-&gt;pretty());
    s.append(<span class="st">&quot;)&quot;</span>);
    <span class="kw">return</span> s;
  }
  bool containsEps() { 
    <span class="kw">return</span> (r1-&gt;containsEps() &amp;&amp; r2-&gt;containsEps());
  }
  bool isPhi() { 
    <span class="kw">return</span> (r1-&gt;isPhi() || r2-&gt;isPhi());
  }
};

class Star : public RE {
 private:
  RE* r;
 public:
  Star (RE* _r) { r = _r; }
  REType ofType() { <span class="kw">return</span> StarType; }
  string pretty() {
    string s;
    s.append(r-&gt;pretty());
    s.append(<span class="st">&quot;*&quot;</span>);
    <span class="kw">return</span> s;
  }
  bool containsEps() { 
    <span class="kw">return</span> true;
  }
  bool isPhi() { 
    <span class="kw">return</span> false;
  }
};



<span class="ot">#endif // __RE__</span></code></pre>
</div>
</body>
</html>
